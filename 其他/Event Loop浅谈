Event Loop即事件循环。最初了解到js的event loop机制是通过自己对js中异步，同步的疑惑。

首先，让我们看一个经典的setTimeout的问题

console.log(1)

setTimeout(function() {
  console.log(2)
}, 1000)

setTimeout(function() {
  console.log(3)
}, 0)

console.log(4)

浏览器打印结果为： 1 4 3 2

接下来，我们就来谈谈js事件循环机制。

想要了解event loop我们就要从js的工作原理说起。首先，我们都知道js是单线程的。所谓单线程就是进程中只有一个线程在运行。那么，js为什么是单线程而不是做成多线程的呢？个人理解，js是用来实现浏览器与用户之间的交互的。如果同时要处理用户点击，用户输入，用户关闭等操作，浏览器无法知道这个时间我到底应该做什么。所以js是从上至下按顺序运行下去的。这里谈及到两个名词，线程与进程。简单介绍：进程，可以理解为正在运行的程序的实体。例如，在手机中打开一个app,打开了一个后台进程。那么，线程又是什么呢？线程是程序执行流的最小单位，也叫轻量级的进程。是程序执行的过程中，一个单一的顺序控制流程。一个进程中，包含很多的线程。单线程，程序执行的过程中，所走的程序路径按照连续的顺序排下来，前面的必须处理好，后面的才会执行。

按照单线程的思想，顺序执行我们的代码，那么，如果我们的js中间向后台发送一个ajax请求，就要等到请求等到结果后才会继续向下执行，如果请求耗时10s，页面就要停在这里10s,这样的用户体验很不好，因此，就有了同步任务、异步任务的区别。所谓异步任务，就好比我们在烧水时同时看书，等到水烧好了，再用烧好的水煮面。这就是一个简单的异步操作。异步可以提高处理事件的效率。异步任务就可以解决单线程按照顺序依次执行，不可以同时进行多个任务的问题。

同步任务和异步任务在js中是如何执行的呢？js的代码运行会形成一个主线程和一个任务队列。主线程会从上到下一步步执行我们的js代码，形成一个执行栈。同步任务就会被放到这个执行栈中依次执行。而异步任务被放到任务队列中执行，执行完就会在任务队列中打一个标记，形成一个对应的事件。当执行栈中的任务全部运行完毕，js会去提取并执行任务队列中的事件。这个过程是循环进行的，这就是我们今天想要了解的event loop.

这里简单粗暴地理解一下异步任务，什么样的任务会被放到任务队列中呢？简单理解，有callback函数的就可以被看作是异步任务，会被放到任务队列中执行。大家可能在使用vue的时候用到过$nextTick方法，这个方法的主要目的就是把事件直接插入到执行栈的最后，而不是放入到任务队列中去执行。这个执行流程就变成了执行栈的任务  ---> $nextTick ---> 任务队列。

我们回头再来看一个最开始提出的问题。console.log(1)和consle.log(4)在主线程的执行栈中执行完，此时，执行栈被清空，js开始执行任务队列中的两个setTimeout事件。先执行延迟时间设置为0秒的setTimeout打印出3，再执行1秒的setTimeout事件，打印出2，最后输出的结果就是1, 4, 3, 2

因为js的event loop机制，所以大家不要认为setTimeout设置的事件到了延迟时间就是被执行。如果你的执行栈任务没有被全部执行完，清空。setTimeout事件执行的时间很有可能要大于你设置的延迟参数。

通过了解js的实现基础和它的执行顺序，进一步让我理解eventloop的工作原理。脑子里有了一个执行机制的大概流程。通过开头的setTimeout引出了事件循环的概念，随着ES6的广泛应用。同样解决异步问题的Promise对象，可以通过它的链式写法，达到写同步代码的手法实现异步任务的效果。那么，Promise和setTimeout在事件队列里是否一样呢？

(async function() {

  console.log(1)

  setTimeout(function() {
    console.log(2)
  }, 0)

  Promise.resolve().then(function() {
    console.log(3)
  }).then(function() {
    console.log(4)
  })

  await aa()

  console.log(5)
})()

function aa() {
  setTimeout(function() {
    console.log(6)
  }, 0)
}

这段js执行的结果是1，5，2，3，4么？大家可以尝试一下。根据上面得到的结论，首先输出的应该是1，5，因为console.log(1)和console.log(5)是执行栈里的同步任务，完成后才进行事件循环。那么setTimeout和Promise的执行顺序是怎样的呢？

这里就要引入两个新名词，microtask、macrotask。即宏任务和微任务。

宏任务： 需要多次事件循环才能执行完，事件队列中的每一个事件都是一个宏任务。浏览器为了能够使得js内部宏任务与DOM任务有序的执行，会在一个宏任务执行结束后，在下一个宏执行开始前，对页面进行重新渲染 （task->渲染->task->…）鼠标点击会触发一个事件回调，需要执行一个宏任务，然后解析HTML。setTimeout的作用是等待给定的时间后为它的回调产生一个新的宏任务。

微任务： 微任务是一次性执行完的。微任务通常来说是需要在当前task执行结束后立即执行的任务，例如对一些动作做出反馈或者异步执行任务又不需要分配一个新的task，这样便可以提高一些性能。只要执行栈中没有其他的js代码正在执行了，而且每个宏任务都执行完了，微任务队列会立即执行。如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。简单理解，宏任务在下一轮事件循环执行，微任务在本轮事件循环的所有任务结束后执行。

宏任务主要包括了：setTimeout、setInterval、setImmediate、I/O、各种事件（比如鼠标单击事件）的回调函数

优先级：主代码块 > setImmediate > MessageChannel > setTimeout / setInterval

微任务主要包括了：process.nextTick、Promise、MutationObserver

优先级：process.nextTick > Promise > MutationObserver