模块热替换(Hot Module Replacement)
模块热替换功能会在应用程序运行过程中替换，添加或删除模块，而无需重新加载整个页面。主要通过以下几种方式，来显著加快开发速度：
  保留在完全重新加载页面时丢失的应用程序状态。
  只更新变更内容，以节省宝贵的开发时间。
  调整样式更加快速，几乎相当于在浏览器调试中更改样式。

这一切是如何运行的？

让我们从一些不同的角度观察，以了解HMR的工作原理

在应用程序中

通过以下步骤，可以做到在应用程序中置换模块：
1.应用程序代码要求HMR runtime检查更新
2 HMR runtime（异步）下载更新，然后通知应用程序代码
3.应用程序代码要求HMR runtime应用更新
4.HMR runtime (异步)应用更新

你可以设置HMR，以使此进程自动触发更新，或者你可以选择要求在用户交互时进行更新。

在编译器中

除了普通资源，编译器需要发出‘update’,以允许更新之前的版本到新的版本。‘update’由两部分组成：
1.更新后的manifest(JSON)
2.一个或多个更新后的chunk(JavaScript)

manifest包括新的编译hash和所有的待更新chunk目录。每个更新chunk都含有对应于此chunk的全部更新模块的代码。

编译器确保模块ID和chunk ID在这些构建之间保持一致。通常将这些ID存储在内存中(例如，使用webpack-dev-server时)，但是也可能将它们存储在一个JSON文件中。

在模块中

HMR是可选功能，只会影响包含HMR代码的模块。举个例子，通过style-loader为style样式追加补丁。为了运行追加补丁，style-loader实现了HMR接口，当它通过HMR收到更新，它会使用新的样式替换旧的样式。

类似的，当在一个模块中实现了HMR接口，你可以描述出当模块被更新后发生了什么。然而在多数情况下，不需要强制在每个模块中写入HMR代码。如果一个模块没有HMR处理函数，更新就会冒泡。这意味着一个简单的处理函数能够对
整个模块树进行更新。如果在这个模块树中，一个单独的模块被更新，那么整组依赖模块都会被重新加载。